### 배열

키를 사용해 식별할 수 있는 값을 담은 컬렉션은 객체라는 자료구조를 이용해 저장한다. 객체만으로도 다양한 작업을 할 수 있다.

첫 번째 요소, 두 번째 요소, 세 번째 요소 등과 같이 **순서가 있는 컬렉션**이 필요할 때가 있다. 사용자나 물건, HTML 요소 목록같이 일목요연하게 순서를 만들어 정렬하기 위해서이다.

**순서가 있는 컬렉션**을 다뤄야 할 때 객체를 사용하면 순서와 관련된 메서드가 없어서 편리하지 않다. 객체는 태생이 순서를 고려하지 않고 만들어진 자료구조이기 때문에 객체를 이용하면 새로운 프로퍼티를 기존 프로퍼티 사이에 끼워 넣는 것도 불가능하다.

이럴 땐 순서가 있는 컬렉션을 저장할 때 쓰는 자료구조인 `배열`을 사용할 수 있다.

### 배열 선언

아래 두 문법을 사용하면 빈 배열을 만들수 있다.

    let arr = new Array();
    let arr = [];

대부분 두 번째 방법으로 배열을 선언하는데, 이때 대괄호 안에 초기 요소를 넣어주는 것도 가능하다.

    let fruits = ["사과", "오렌지", "자두"];

각 배열 요소엔 0부터 시작하는 숫자(인덱스)가 매겨져 있다. 이 숫자들은 배열 내 순서를 의미한다.

배열 내 특정 요소를 얻고 싶으면 대괄호 안에 순서를 나타내는 숫자인 인덱스를 넣어주면 된다.

    let fruits = ["사과", "오렌지", "자두"];

    alert(fruits[0]); // 사과
    alert(fruits[1]); // 오렌지
    alert(fruits[2]); // 자두

같은 방법으로 요소를 수정할 수 있다.

    fruits[2] = "배"; // 배열의 2번째 요소 자두를 -> 배로 변경함

배열에 새로운 요소를 추가하는 것도 가능하다.

    fruits[3] = "레몬"; // 배열의 3번째에 레몬을 추가함

`length`를 사용하여 배열에 담긴 요소가 몇 개인지 알아낼 수 있다.

    let fruits = ["사과","오렌지","자두"];
    alert(fruits.length); // 3

`alert`를 사용해 요소 전체를 출력하는 것도 가능하다.

    let fruits = ["사과", "오렌지", "자두"];
    alert(fruits); // 사과, 오렌지, 자두

배열 요소의 자료형엔 제약이 없다.

    // 요소에 여러 가지 자료형이 섞여 있다.
    let arr = ['사과', {name: '이보라'}, true, function() {alert('안녕하세요);}];

    // 인덱스가 1인 요소(객체)의 name 프로퍼티를 출력한다.
    alert(arr[1].name); // 이보라

    // 인덱스가 3인 요소(함수)를 실행한다.
    arr[3]();

### pop-push와 shift-unshift

**큐(queue)**는 배열을 사용해 만들 수 있는 대표적인 자료구조로, 배열과 마찬가지로 순서가 있는 컬렉션을 저장하는 데 사용한다. 큐에서 사용하는 주요 연산은 아래와 같다.

- `push` - 맨 끝에 요소를 추가
- `shift` - 제일 앞 요소를 꺼내 제거한 후 남아있는 요소들을 앞으로 밀어준다. 이렇게 하면 두 번째 요소가 첫 번째 요소가 된다.

배열에 두 연산을 가능하게 해주는 내장 메서드 `push`와 `pop`이 있다.

화면에 순차적으로 띄울 메시지를 비축해 놓을 자료 구조를 만들 때 큐를 사용하는 것처럼 큐는 실무에서 상당히 자주 쓰이는 자료구조이다.

배열은 큐 이외에 **스택**이라 불리는 자료구조를 구현할 때도 쓰인다.

스택에서 사용하는 연산은 아래와 같다.

 - `push` - 요소를 스택 끝에 집어 넣는다.
 - `pop` - 스택 끝 요소를 추출한다.

 스택은 이처럼 '한쪽 끝'에 요소를 더하거나 뺄 수 있게 해주는 자료구조이다.

 스택을 사용하면 가장 나중에 집어넣은 요소가 먼저 나온다. 이런 특징을 후입선출(Last-In-First-Out, LIFO)라고 부른다. 반면 큐를 사용하면 먼저 넣은 집어넣은 요소가 먼저 나오기 때문에 큐는 선입선출(First-In-First-Out, FIFO) 자료구조라고 부른다.

 이렇게 처음이나 끝에 요소를 더하거나 빼주는 연산을 제공하는 자료구조를 컴퓨터 과학 분야에서는 데큐(deque, Double Enede Queue)라고 부른다.

 아래는 배열 끝에 무언가를 해주는 메서드이다.

 `pop`    
 배열 끝 요소를 제거하고, 제거한 요소를 반환한다.

    let fruits = ["사과", "오렌지", "배"];

    alert(fruits.pop() ); // 배열에서 "배"를 제거하고 제거된 요소를 얼럿창에 띄운다.

    alert(fruits); // 사과,오렌지

`push`    
배열 끝에 요소를 추가한다.

    let fruits = ["사과", "오렌지"];

    fruits.push("배");

    alert(fruits); // 사과, 오렌지, 배

아래는 배열 앞에 무언가를 해주는 메서드이다.

`shift`    
배열 앞 요소를 제거하고, 제거한 요소를 반환한다. = 제거된 요소를 제외한 요소들이 얼럿창에 나온다

    let fruits = ["사과", "오렌지", "배"];

    alert( fruits.shift() ); // 배열에서 "사과"를 제거하고 제거된 요소를 얼럿창에 띄웁니다.

    alert( fruits ); // 오렌지,배

`unshift`    
배열 앞에 요소를 추가한다.

    let fruits = ["오렌지", "배"];

    fruits.unshift('사과');

    alert( fruits ); // 사과,오렌지,배

`push`와 `unshift`는 요소 여러 개를 한 번에 더해줄 수도 있다.

    let fruits = ["사과"];

    fruits.push("오렌지", "배"); // 배열 뒤에 추가
    fruits.unshift("파인애플", "레몬"); // 배열 앞에 추가

    // ["파인애플", "레몬", "사과", "오렌지", "배"]
    alert( fruits );

### 배열 동작 원리

배열은 특별한 종류의 객체이다. 배열 `arr`의 요소를 `arr[0]` 처럼 대괄호를 사용해 접근하는 방식은 객체 문법에서 왔다. 다만 배열은 키가 숫자라는 점만 다르다.

숫자형 키를 사용함으로써 배열은 객체 기본 기능 이외에도 순서가 있는 컬렉션을 제어하게 해주는 특별한 메서드를 제공한다. `length`라는 프로퍼티도 제공한다.

배열은 자바스크립트의 일곱 가지 원시 자료형에 해당되지 않고, 원시 자료형이 아닌 객체형에 속하기 때문에 객체처럼 동작한다.

배열은 객체와 마찬가지로 참조를 통해 복사된다. 아래 예시를 보자 

    let fruits = ["바나나"]

    let arr = fruits; // 참조를 복사함(두 변수가 같은 객체를 참조)

    alert(arr === fruits); // true

    arr.push("배");

    alert(fruits); // 바나나,배 - 요소가 두 개가 되었다.

배열을 배열답게 만들어주는 것은 특수 내부 표현방식이다. 자바스크립트 엔진은 배열의 요소를 인접한 메모리 공간에 차례로 저장해 연산 속도를 높인다. 이 방법 이외에도 배열 관련 연산을 더 빠르게 해주는 최적화 기법은 다양하다.

그런데 개발자가 배열을 '순서가 있는 자료의 컬렉션'처럼 다루지 않고 일반 객체처럼 다루면 이런 기법들이 제대로 동작하지 않는다.

아래 예시를 살펴보자.

    let fruits =[]; // 빈 배열 생성

    fruits[99999] = 5; // 배열의 길이보다 훨씬 큰 숫자를 사용해 프로퍼티를 만든다.

     fruits.age = 25; // 임이의 이름을 사용해 프로퍼티를 만든다.

배열은 객체이므로 예시처럼 원하는 프로퍼티를 추가해도 문제가 발생하지 않는다.

그런데 이렇게 코드를 작성하면 자바스크립트 엔진이 배열을 일반 객체처럼 다루게 되어 배열을 다룰 때만 적용되는 최적화 기법이 동작하지 않아 배열 특유의 이점이 사라지게 된다.

잘못된 방법의 예는 아래와 같다.

- `arr.test = 5` 같이 숫자가 아닌 값을 프로퍼티 키로 사용하는 경우
- `arr[0]`과 `arr[1000]`만 추가하고 그 사이에 아무런 요소도 없는 경우
- `arr[1000]`, `arr[999]` 같이 요소를 역순으로 채우는 경우

배열은 순서가 있는 자료를 저장하는 용도로 만들어진 특수한 자료구조이다. 배열 내장 메서드들은 이런 용도에 맞게 만들어졌다. 임의의 키를 사용해야 한다면 배열보단 일반 객체 `{}`가 적합한 자료구조일 확률이 높다.

### 성능

`push`와 `pop`은 빠르지만 `shift`와 `unshift`는 느리다.

배열 앞에 무언가를 해주는 메서드가 배열 끝에 무언가를 해주는 메서드보다 느린 이유를 실행 흐름을 통해 살펴보자.

    fruits.shift(); // 배열 맨 앞의 요소를 제거한다.

`shift`(배열 앞 요소를 제거하고, 제거한 요소 반환) 메서드를 호출한 것과 동일한 효과를 보려면 인덱스가 `0`인 요소를 제거하는 것만으론 충분하지 않다. 제거 대상이 아닌 나머지 요소들의 인덱스를 수정해 줘야 한다.

`shift` 연산은 아래 3가지 동작을 모두 수행해야 이뤄진다.

1. 인덱스가 `0`인 요소를 제거한다.
2. 모든 요소를 왼쪽으로 이동시킨다. 이때 인덱스 `1`은 `0`, `2`는 `1`로 변경된다.
3. `length` 프로퍼티 값을 갱신한다.

극단적으로 생각해보자, 배열에 요소가 1억개고 1억개의 요소가 이동하는 데 걸리는 시간이 길고 메모리 관련 연산도 많아진다 -> 그래서 성능적으로 별로임

`unshift` 를 실행했을 때도 이와 유사하다. 요소를 배열 앞에 추가하려면 일단 기존 요소들을 오른쪽으로 이동시켜야 하는데, 이때 인덱스도 바꿔줘야함.

**그렇다면** `push`나 `pop` 은 어떻게 동작할까?, 이 두 개는 요소 이동을 수반하지 않는다.

`pop` 메서드로 요소를 끝에서 제거하려면 마지막 요소를 제거하고 `length` 프로퍼티의 값을 줄여주기만 하면 된다.

`pop` 메서드는 요소를 옮기지 않으므로 각 요소는 기존 인덱스를 그대로 유지한다. 배열 끝에 무언가를 해주는 메서드의 실행 속도가 빠른 이유는 바로 여기에 있다.

`push` 메서드도 유사한 동작이 일어난다.

**정리하자면**

배열의 앞부분에 요소를 추가하는 메서드가 배열의 끝부분에 요소를 추가하는 메서드보다 느린 이유는? 배열의 내부 동작 방식과 관련이 있다.

- `push` 메서드
1. 배열의 끝에 요소를 추가한다.
2. 새로운 요소를 추가하는 위치는 배열의 마지막 인덱스이다.
3. 배열의 길이만 조정하고 새로운 요소를 마지막 위치에 추가하기 때문에 매우 빠르다.

- `unshift` 메서드
1. 배열의 앞에 요소를 추가한다.
2. 배열의 모든 기존 요소를 오른쪽으로 한 칸씩 이동시켜야 한다.
3. 배열의 길이를 조정하고 새로운 요소를 인덱스 0에 추가해야 한다.

**내부 동작 비교를 하자면 `push`는 배열의 끝에 새로운 요소를 추가하는 것은 O(1) 시간 복잡도를 가진다.
즉, 배열의 크기와 상관없이 일정한 시간이 걸린다.**

**`unshift`는 배열의 앞에 새로운 요소를 추가하는 것은 O(n) 시간 복잡도를 가진다. 배열의 모든 요소를 오른쪽으로 한 칸씩 이동시켜야 하므로 배열의 크기에 비례하여 시간이 증가한다.

push와 pop은 배열의 마지막에만 변화를 주는 추가,제거 이기 떄문에 배열의 길이와 상관없이 연산이 마지막으로 고정되어 있기 때문에 단순해서 작업이 빠른데 반면, shift와 unshift는 
배열의 앞에 추가하거나 제거하고 제거된 상태를 반환해야 하기 때문에 수정도되야하고 배열의 길이가 길면 시간이 오래 걸리기 때문

### 반복문

`for`문은 배열을 순회할 때 쓰는 가장 오래된 방법이다. 순회시엔 인덱스를 사용한다.

    let arr = ["사과", "오렌지", "배"];

    for (let i=0; i < arr.length; i++) {
        alert(arr[i]);
    }
alert 창에 사과 출력 다음 오렌지 다음 배

또 다른 순회 문법으론 `for..of`가 있다.

    let fruits = ["사과", "오렌지", "자두"];

    // 배열 요소를 대상으로 반복 작업을 수행한다.
    for (let fruit of fruits) {
        alert(fruit);
    }

`for..of`를 사용하면 현재 요소의 인덱스는 얻을 수 없고 값만 얻을 수 있다. 배열의 요소를 대상으로 반복 작업을 할 땐, `for..of`를 사용해보자.

배열은 객체형에 속하므로 `for..in`을 사용하는 것도 가능하다.

    `let arr = ["사과", "오렌지", "배"];

    for (let key in arr) {
        alert(arr[key]); // 사과,오렌지,배
    }

그런데 `for..in`은 다음과 같은 특징을 지니기 때문에 배열에 `for..in`을 사용하면 문제가 발생하므로 되도록 다른 반복문을 사용하자.

1. `for..in` 반복문은 모든 프로퍼티를 대상으로 순회한다. 키가 숫자가 아닌 프로퍼티도 순회 대상에 포함된다.    

브라우저나 기타 호스트 환경에서 쓰이는 객체 중, 배열과 유사한 형태를 보이는 '유사 배열' 객체가 있다. 유사 배열 객체엔 배열처럼 `length` 프로퍼티도 있고 요소모다 인덱스도 붙어 있다. 그런데 여기에 더하여 유사 배열 객체엔 배열과는 달리 키가 숫자형이 아닌 프로퍼티와 메서드가 있을 수 있다. 유사 배열 객체와 `for..in`을 함께 사용하면 이 모든 것을 대상으로 순회가 이뤄진다. 따라서 '필요 없는' 프로퍼티들이 문제를 일으킬 가능성이 높다.

2. `for..in` 반복문은 배열이 아니라 객체와 함께 사용할 때 최적화되어 있어서 배열에 사용하면 객체에 사용하는 것 대비 10~100배 정도 느리다. `for..in` 반복문의 속도가 대체로 빠른 편이기 때문에 `for..in` 반복문을 사용할 땐 이런 차이를 알고 적절한 곳에 사용하자.

그러니 배열엔 되도록 `for..in` 쓰지 말자!!!!

### length 프로퍼티

배열에 무언가 조작을 가하면 `length` 프로퍼티가 자동으로 갱신된다.

`length` 프로퍼티는 배열 내 요소의 개수가 아니라 가장 큰 인덱스에 1을 더한 값이다.

따라서 배열에 요소가 하나 있고, 이 요소의 인덱스가 아주 큰 정수라면 배열의 `length` 프로퍼티도 아주 커진다.

    let fruits = [];
    fruits[123] = "사과";

    alert(fruits.length); // 124

배열을 이렇게 사용하지 말자.

`length` 프로퍼티의 또 다른 독특한 특징 중 하나는 쓰기가 가능하다는 점이다.

`lenghte`의 값을 수동으로 증가시키면 아무 일도 일어나지 않는다. 그런데 값을 감소시키면 배열이 잘린다. 짧아진 배열은 다시 되돌릴 수 없다.

    let arr = [1, 2, 3, 4, 5];

    arr.length = 2; // 요소 2개만 남기고 잘라보자
    alert(arr); // [1, 2]

    arr.length = 5; // 본래 길이로 되돌려보자.
    alert(arr[3]); // undefined: 삭제된 기존 요소들이 복구되지 않는다.

이런 특징을 이용하면 `arr.length = 0;`을 사용해 아주 간단하게 배열을 비울 수 있다.

### new Array()
`new Array()` 문법을 사용해도 배열을 만들 수 있다.

    let arr = new Array("사과", "배", "기타");

대괄호 `[]`를 사용하면 더 짧은 문법으로 배열을 만들 수 있기 때문에 `new Array()`는 잘 사용되지 않는 편이다. `new Array()`엔 다루기 까다로운 기능도 있어서 더욱 더 그렇다.

숫자형 인수 하나를 넣어서 `new Array`를 호출하면 배열이 만들어지는데, 이 배열엔 요소가 없는 반면 길이는 인수와 같아진다.

    let arr = new Array(2); // 이렇게 하면 배열 [2]가 만들어질까?

    alert(arr[0]); // undefined가 출력된다. 요소가 하나도 없는 배열

    alert(arr.length); // 길이는 2이다

`new Array(number)`를 이용해 만든 배열의 요소는 모두 `undefined`이다.

이런 뜻밖의 상황을 피하기 위해 `new Array`의 기능을 잘 알지 않는 한 대부분의 개발자가 대괄호를 써서 배열을 만든다.

### 다차원 배열

배열 역시 배열의 요소가 될 수 있다. 이런 배열을 가리켜 다차원 배열이라 부른다. 다차원 배열은 행렬을 저장하는 용도로 쓰인다.

    let matrix = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ];

    alert(matrix[1][1]); // 5, 중심에 있는 요소

### toString

배열엔 `toString` 메서드가 구현되어 있어 이를 호출하면 요소를 쉼표로 구분한 문자열이 반환된다.

    let arr = [1, 2, 3];

    alert(arr); // 1,2,3
    alert( String(arr) === '1,2,3'); // true

아래 예시를 실행해 보자

    alert( [] + 1 ); // 1
    alert( [1] + 1 ); // 11
    alert( [1,2] + 1 ); // 1,21

배열엔 `Symbol.toPrimitive`나 `valueOf` 메서드가 없다. 따라서 위 예시에선 **문자열로의 형 변환이 일어나** `[]`는 빈 문자열, `[1]`은 문자열 `1`, `[1,2]`는 문자열 `1,2`로 변환된다.


정리하자면, [1,2]는 문자열 1,2로 변환되고 뒤에 + 1 은 이항 덧셈 연산자로 인해 피연산자중 하나가 문자열 1,2 이므로 + 1 도 문자열로 변환된다 그래서 1,2 + 1 = 1,21이 된다?

### 요약

배열은 특수한 형태의 객체로, 순서가 있는 자료를 저장하고 관리하는 용도에 최적화된 자료구조이다.

- 선언 방법
    // 대괄호 (가장 많이 쓰이는 방법)
    let arr = [item1, item2...];

    // new Array(잘 쓰이지 않음)
    let arr = new Array(item1, item2...);

`new Array(number)`을 호출하면 길이가 `number`인 배열이 만들어지는데, 이 때 요소는 비어 있다.

- `length` 프로퍼티는 배열의 길이를 나타낸다. 정확히는 숫자형 인덱스 중 가장 큰 값에 1을 더한 값이다. 배열 메서드는 `length` 프로퍼티를 자동으로 조정해준다.
- `length` 값을 수동으로 줄이면 배열 끝이 잘린다.

다음 연산을 사용하면 배열을 데큐처럼 사용할 수 있다.

- `push(...items)` - `items`를 배열 끝에 더해준다.
- `pop()` - 배열 끝 요소를 제거하고, 제거한 요소를 반환한다.
- `shift()` - 배열 처음 요소를 제거하고, 제거한 요소를 반환한다.
- `unshift(...items)` - `items`를 배열 처음에 더해준다.

아래 방법을 사용하면 모든 요소를 대상으로 반복 작업을 할 수 있다.

- `for (let i=0; i<arr.length; i++)` - 가장 빠른 방법이고 오래된 브라우저와도 호환된다.
- `for (let item of arr)` - 배열 요소에만 사용되는 모던한 문법이다.
- `for (let i in arr)` - 배열엔 절대 사용하지 말 것!!!!


        function sumInput() {

        let numbers = [];

        while (true) {

        let value = prompt("숫자를 입력해 주세요.", 0);

        // 입력받는 것을 정지해야 하는 경우
        if (value === "" || value === null || !isFinite(value)) break;

        numbers.push(+value);
        }

        let sum = 0;
        for (let number of numbers) {
            sum += number;
        }
        return sum;
        }

        alert( sumInput() );










































