## 변수의 유효범위와 클로저
자바스크립트는 함수 지향 언어이다. 함수를 동적으로 생성할 수 있고, 생성한 함수를 다른 함수에 인수로 넘길 수 있으며, 생성된 곳이 아닌 곳에서 함수를 호출할 수도 있기 때문이다.

함수 내부에서 함수 외부에 있는 변수에 접근할 수 있다는 사실을 알고 있다.

그런데 함수가 생성된 이후에 외부 변수가 변경된다면 어떤 일이 발생할까?? 함수는 새로운 값을 가져올까, 아니면 생성 시점 이전의 값을 가져올까

매개변수를 통해 함수를 넘기고 이 함수를 저 멀리 떨어진 코드에서 호출할 땐 어떤 일이 발쌩할까?? 함수는 호출 되는 곳을 기준으로 외부 변수에 접근할까?

간단한 시나리오를 통해 알아보자.

## 코드 블록

코드 블록 `{...}` 안에서 선언한 변수는 블록 안에서만 사용할 수 있다.

    {
      // 지역 변수를 선언하고 몇 가지 조작을 했지만 그 결과를 밖에서 볼 수 없다.

      let message = "안녕하세요."; // 블록 내에서만 변수값을 얻을 수 있다.

      alert(message); // 안녕하세요.
    }

    alert(message); // message is not defined

이런 블록의 특징은 특정 작업을 수행하는 코드를 한데 묶어두는 용도로 활용할 수 있다 블록 안엔 작업 수행에만 필요한 변수가 들어간다.

    {
      // 메시지 출력
      let message = "안녕하세요.";
      alert(message);
    }

    {
      // 또 다른 메시지 출력
      let message = "안녕히 가세요.";
      alert(message);
    }

---
**블록이 없으면 에러가 발생한다.**

이미 선언된 변수와 동일한 이름을 가진 변수를 별도의 블록 없이 `let`으로 선언하면 에러가 발생한다.

    // 메시지 출력
    let message = "안녕하세요.";
    alert(message);

    // 또 다른 메시지 출력
    let message = "안녕히 가세요."; // message has already been 
    alert(message);

`if` 블록 밖에 있는 `alert`는 `phrase`에 접근할 수 없기 때문에 위 코드를 실행하면 에러가 발생한다.

이런 특징은 변수의 유효 범위를 블록 범위, 특히 `if` 분기문 범위로 한정시킬 수 있어서 아주 유용하다.

`if` 뿐만 아니라 `for`, `while` 반복문에서도 동일한 특징이 적용된다.

    for (let i = 0; i < 3; i++) {
      // 변수 i는 for 안에서만 사용할 수 있다.
      alert(i); // 0,1,2 출력
    }
    alert(i); // i is not defined

`for`문에서 `for` 옆 괄호 안에서 선언한 변수 `let i`는 `{...}` 밖에 있긴 하지만 블록 `{...}`에 속하는 코드로 취급된다.

## 중첩 함수

함수 내부에서 선언한 함수는 '중첩'함수라고 부른다.

중첩 함수는 아래와 같이 코드를 정돈하는데 사용할 수 있다.

    function sayHiBye(firstName, lastName) {

      // 헬퍼(helper) 중첩 함수
      function getFullName() {
        return firstName + " " + lastName;
      }

      alert( "Hello, " + getFullName() );
      alert( "Bye, " + getFullName() );

    }

위 코드에서 외부 변수에 접근해 이름 전체를 반환해주는 **중첩**함수 `getFullName()`은 편의상 만든 함수이다.

중첩 함수는 새로운 객체의 프로퍼티 형태나 중첩 함수 그 자체로 반환될 수 있다. 이렇게 반환된 중첩 함수는 어디서든 호출해 사용할 수 있다. 물론 이때도 외부 변수에 접근할 수 있다는 사실은 변함 없다.

아래 함수 `makeCounter`는 호출될 때마다 다음 숫자를 반환해주는 '카운터'함수를 만든다.

    function makeCounter() {
      let count = 0;

      return function() {
        return count++;
      };
    }

    let counter = makeCounter();

    alert( counter() ); // 0
    alert( counter() ); // 1
    alert( counter() ); // 2

예시의 `makeCounter`는 아주 단순하지만, 여기에 약간의 변형을 가하면 **난수 생성기** 같은 실용성 있는 함수를 만들 수 있다.

그런데 `makeCounter`를 살펴보다 보면 `counter`를 여러 개 만들었을 때, 이 함수들은 서로 독립적일까? 함수와 중첩 함수 내 `count` 변수엔 어떤 값이 할당될까?


## 단계 1. 변수

자바스크립트에선 실행 중인 함수, 코드 블록 `{...}`, 스크립트 전체는 ***렉시컬 환경***이라 불리는 내부 숨김 연관 객체를 갖는다.

렉시컬 환경 객체는 두 부분으로 구성된다.

1. **환경 레코드** - 모든 지역 변수를 프로퍼티로 저장하고 있는 객체이다. `this` 값과 같은 기타 정보도 여기에 저장된다.
2. **외부 렉시컬 환경에 대한 참조** - 외부 코드와 연관됨

**'변수'는 특수 내부 객체인 `환경 레코드`의 프로퍼티일 뿐이다. 변수를 가져오거나 변경 하는 것은 환경 레코드의 프로퍼티를 가져오고나 변경 함을 의미한다.**

아래 두 줄짜리 코드엔 렉시컬 환경이 하나만 존재한다.

    let phrase = "Hello";
    alert(phrase)

let phrase = "Hello"; ------- Lexical Environment phrase: "Hello" ->(outer) null

이렇게 스크립트 전체와 관련된 렉시컬 환경은 전역 렉시컬 환경(global Lexical Environment)이라고 한다.

위 코드에서 phrase: "Hello" 는 변수가 저장되는 환경 레코드를 나타내고 화살표는 외부 렉시컬 환경에 대한 참조를 나타낸다. 전역 렉시컬 환경은 외부 참조를 갖지 않기 때문에 화살표가 `null`을 가리킨다.

코드가 실행되고 실행 흐름이 이어져 나가면서 렉시컬 환경은 변화한다.

    execution start ------- phrase: <uninitialized> ->(outer) null
    
    let phrase; ------- phrase: undefined
    phrase = "Hello"; ------- phrase: "Hello"
    phrase = "Bye"; ------ phrase: "Bye"

우측의 phrase 들은 코드가 한 줄, 한 줄 실행될 때마다 전역 렉시컬 환경이 어떻게 변화하는지 보여준다.

1. 스크립트가 시작되면 스크립트 내에서 선언한 변수 전체가 렉시컬 환경에 올라간다(pre-populated)
- 이때 변수의 상태는 특수 내부 상태인 'uninitialized'가 된다. 자바스크립트 엔진은 uninitialized 상태의 변수를 인지하긴 하지만, `let`을 만나기 전까진 이 변수를 참조할 수 없다.

2. `let phrase`가 나타났다. 아직 값을 할당하기 전이기 때문에 프로퍼티 값은 `undefined`이다. `phrase`는 이 시점 이후부터 사용할 수 있다.
3. `phrase`에 값이 할당되었다.
4. `phrase`의 값이 변경되었다.

요약해보면    
- 변수는 특수 내부 객체인 환경 레코드의 프로퍼티이다. 환경 레코드는 현재 실행 중인 함수와 코드 블록, 스크립트와 연관되어 있다.
- 변수를 변경하면 환경 레코드의 프로퍼티가 변경된다.

---
**렉시컬 환경은 명세서에만 존재한다**
'렉시컬 환경'은 **명세서**에서 자바스크립트가 어떻게 동작하는지 설명하는 데 쓰이는 '이론상'의 객체이다. 따라서 코드를 사용해 직접 렉시컬 환경을 얻거나 조작하는 것은 불가능하다.

## 단계 2. 함수 선언문

함수는 변수와 마찬가지로 값이다.

**다만 함수 선언문으로 선언하 함수는 일반 변수와는 달리 바로 초기화된다는 점에서 차이가 있다.

함수 선언문으로 선언한 함수는 렉시컬 환경이 만들어지는 즉시 사용할 수 있다. 변수는 `let`을 만나 선언이 될 때까지 사용할 수 없지만

선언되기 전에도 함수를 사용할 수 있는 것은 바로 이 때문이다.

아래 코드는 스크립트에 함수를 추가했을 때 전역 렉시컬 환경 초기 상태가 어떻게 변하는지 보여준다.

    exectuion start -------- phrase: <uninitialized> -> (outer) null

    let phrase = "Hello"; -------- ...

    function say(name) {
      alert(  '${phrase}, ${name}' );
    }

이런 동작 방식은 함수 선언문으로 정의한 함수에만 적용된다. `let say = function(name)...` 같이 함수를 변수에 할당한 함수 표현식은 해당되지 않는다.

## 단계 3. 내부와 외부 렉시컬 환경

